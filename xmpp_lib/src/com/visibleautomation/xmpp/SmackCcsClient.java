package com.visibleautomation.xmpp;
import org.jivesoftware.smack.ConnectionConfiguration.SecurityMode;
import org.jivesoftware.smack.ConnectionListener;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.SmackException.NotConnectedException;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.packet.DefaultExtensionElement;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Stanza;
import org.jivesoftware.smack.filter.StanzaFilter;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;
import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration;
import org.jivesoftware.smack.util.StringUtils;
import org.json.simple.JSONValue;
import org.json.simple.parser.ParseException;
import org.xmlpull.v1.XmlPullParser;
import org.jivesoftware.smack.*;
import org.jivesoftware.smack.packet.ExtensionElement;
import org.jivesoftware.smack.provider.ExtensionElementProvider;
import org.jivesoftware.smack.roster.Roster;
import org.jivesoftware.smack.util.stringencoder.Base64;
import org.jivesoftware.smack.util.XmlStringBuilder;
import org.jivesoftware.smack.sasl.packet.SaslStreamElements.AuthMechanism;
import org.jivesoftware.smack.packet.PlainStreamElement;
import org.jivesoftware.smack.sasl.packet.SaslStreamElements;
import org.jivesoftware.smack.SASLAuthentication;
import org.jivesoftware.smack.sasl.provided.SASLPlainMechanism;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;


import javax.net.ssl.SSLSocketFactory;

/**
 * Sample Smack implementation of a client for GCM Cloud Connection Server. This
 * code can be run as a standalone CCS client.
 *
 */
public class SmackCcsClient {

    private static final String GCM_ELEMENT_NAME = "gcm";
    public static final String GCM_NAMESPACE = "google:mobile:data";
	// temporary for stanza debugging
    private static final String YOUR_PROJECT_ID = "1012198772634";
    
    static {

        ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE, new  ExtensionElementProvider<ExtensionElement>() {
            @Override
            public DefaultExtensionElement parse(XmlPullParser parser,int initialDepth) throws org.xmlpull.v1.XmlPullParserException,
            IOException {
                String json = parser.nextText();
                return new GcmPacketExtension(json);
            }
        });
    }

    private XMPPTCPConnection connection;

    /**
     * Indicates whether the connection is in draining state, which means that it
     * will not accept any new downstream messages.
     */
    protected volatile boolean connectionDraining = false;

    /**
     * Sends a downstream message to GCM.
     *
     * @return true if the message has been successfully sent.
     */
    public boolean sendDownstreamMessage(String jsonRequest) throws NotConnectedException, InterruptedException {
        if (!connectionDraining) {
            send(jsonRequest);
            return true;
        }
        System.out.println("Dropping downstream message since the connection is draining");
        return false;
    }

    /**
     * Returns a random message id to uniquely identify a message.
     *
     * <p>Note: This is generated by a pseudo random number generator for
     * illustration purpose, and is not guaranteed to be unique.
     */
    public String nextMessageId() {
        return "m-" + UUID.randomUUID().toString();
    }

    /**
     * Sends a packet with contents provided.
     */
    protected void send(String jsonRequest) throws NotConnectedException, InterruptedException {
        Stanza request = new GcmPacketExtension(jsonRequest).toPacket();
        connection.sendStanza(request);
    }

    /**
     * Handles an upstream data message from a device application.
     *
     * <p>This sample echo server sends an echo message back to the device.
     * Subclasses should override this method to properly process upstream messages.
     */
    protected void handleUpstreamMessage(Map<String, Object> jsonObject) throws InterruptedException {
        // PackageName of the application that sent this message.
        String category = (String) jsonObject.get("category");
        String from = (String) jsonObject.get("from");
		System.out.println("upstream message");
		for (String key : jsonObject.keySet()) {
			System.out.println("received key " + key);
		}
    }

    /**
     * Handles an ACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle ACKs.
     */
    protected void handleAckReceipt(Map<String, Object> jsonObject) {
        String messageId = (String) jsonObject.get("message_id");
        String from = (String) jsonObject.get("from");
        System.out.println("handleAckReceipt() from: " + from + ",messageId: " + messageId);
    }

    /**
     * Handles a NACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle NACKs.
     */
    protected void handleNackReceipt(Map<String, Object> jsonObject) {
        String messageId = (String) jsonObject.get("message_id");
        String from = (String) jsonObject.get("from");
        System.out.println("handleNackReceipt() from: " + from + ",messageId: " + messageId);
    }

    protected void handleControlMessage(Map<String, Object> jsonObject) {
        System.out.println("handleControlMessage(): " + jsonObject);
        String controlType = (String) jsonObject.get("control_type");
        if ("CONNECTION_DRAINING".equals(controlType)) {
            connectionDraining = true;
        } else {
            System.out.println(String.format("Unrecognized control type: %s. This could happen if new features are " + "added to the CCS protocol.", controlType));
        }
    }

    /**
     * Creates a JSON encoded GCM message.
     *
     * @param to RegistrationId of the target device (Required).
     * @param messageId Unique messageId for which CCS sends an
     *         "ack/nack" (Required).
     * @param payload Message content intended for the application. (Optional).
     * @param collapseKey GCM collapse_key parameter (Optional).
     * @param timeToLive GCM time_to_live parameter (Optional).
     * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
     * @return JSON encoded GCM message.
     */
    public static String createJsonMessage(String to, String messageId,
            Map<String, String> payload, String collapseKey, Long timeToLive,
            Boolean delayWhileIdle) {
        Map<String, Object> message = new HashMap<String, Object>();
        message.put("to", to);
        if (collapseKey != null) {
            message.put("collapse_key", collapseKey);
        }
        if (timeToLive != null) {
            message.put("time_to_live", timeToLive);
        }
        if (delayWhileIdle != null && delayWhileIdle) {
            message.put("delay_while_idle", true);
        }
      message.put("message_id", messageId);
      message.put("data", payload);
      return JSONValue.toJSONString(message);
    }

    /**
     * Creates a JSON encoded ACK message for an upstream message received
     * from an application.
     *
     * @param to RegistrationId of the device who sent the upstream message.
     * @param messageId messageId of the upstream message to be acknowledged to CCS.
     * @return JSON encoded ack.
     */
        protected static String createJsonAck(String to, String messageId) {
        Map<String, Object> message = new HashMap<String, Object>();
        message.put("message_type", "ack");
        message.put("to", to);
        message.put("message_id", messageId);
        return JSONValue.toJSONString(message);
    }

    /**
     * Connects to GCM Cloud Connection Server using the supplied credentials.
     * @param senderId Your GCM project number
     * @param apiKey API Key of your project
	 * @param gcmServer Google Cloud Messaging Server
	 * @param gcmPort Google Cloud Messaging TCP port
     */
    public void connect(String senderId, String apiKey, String gcmServer, int gcmPort)
            throws XMPPException, IOException, SmackException, InterruptedException {
	System.out.println("senderId = " + senderId + " apiKey = " + apiKey);
    	XMPPTCPConnectionConfiguration config =
    			XMPPTCPConnectionConfiguration.builder()
    		     .setHost(gcmServer)
				 .setServiceName(gcmServer)
    		     .setCompressionEnabled(false)
    		     .setPort(gcmPort)
			     .setUsernameAndPassword(senderId, apiKey) 
    		     .setConnectTimeout(30000)
				 .setDebuggerEnabled(true)
    		     .setSecurityMode(SecurityMode.disabled)
    		     .setSendPresence(false)
    		     .setSocketFactory(SSLSocketFactory.getDefault())
    		    .build();
    	
        //connection = new FixedXMPPTCPConnection(config, senderId, apiKey);
        connection = new XMPPTCPConnection(config);
        
        //disable Roster as I don't think this is supported by GCM
        Roster roster = Roster.getInstanceFor(connection);
        roster.setRosterLoadedAtLogin(false);

        System.out.println("Connecting...");
		connection.setPacketReplyTimeout(10000);
        connection.connect();

        connection.addConnectionListener(new LoggingConnectionListener());

        // Handle incoming packets
        connection.addAsyncStanzaListener(new MyStanzaListener() , new MyStanzaFilter());

        // Log all outgoing packets
        connection.addPacketInterceptor(new MyStanzaInterceptor(), new MyStanzaFilter());

        connection.login(senderId + "@gcm.googleapis.com" , apiKey);
        
    }
    
    private class MyStanzaFilter implements StanzaFilter {
    
		@Override
		public boolean accept(Stanza arg0) {
			// TODO Auto-generated method stub
			if(arg0.getClass() == Stanza.class) {
				return true;
			} else {
/*
				if (arg0.getTo()!= null) {
					if(arg0.getTo().startsWith(YOUR_PROJECT_ID)) {
						return true;
					}
				}
*/
			}
			return false;
		}
    }
    
    private class MyStanzaListener implements StanzaListener{
		
        @Override
        public void processPacket(Stanza packet) {
            System.out.println("Received: " + packet.toXML());
            Message incomingMessage = (Message) packet;
            GcmPacketExtension gcmPacket = (GcmPacketExtension) incomingMessage.getExtension(GCM_NAMESPACE);
            String json = gcmPacket.getJson();
            try {
                @SuppressWarnings("unchecked")
                Map<String, Object> jsonObject = (Map<String, Object>) JSONValue.parseWithException(json);

                // present for "ack"/"nack", null otherwise
                Object messageType = jsonObject.get("message_type");

                if (messageType == null) {
                    // Normal upstream data message
                    handleUpstreamMessage(jsonObject);

                    // Send ACK to CCS
                    String messageId = (String) jsonObject.get("message_id");
                    String from = (String) jsonObject.get("from");
                    String ack = createJsonAck(from, messageId);
                    send(ack);
                } else if ("ack".equals(messageType.toString())) {
                      // Process Ack
                      handleAckReceipt(jsonObject);
                } else if ("nack".equals(messageType.toString())) {
                      // Process Nack
                      handleNackReceipt(jsonObject);
                } else if ("control".equals(messageType.toString())) {
                      // Process control message
                      handleControlMessage(jsonObject);
                } else {
                      System.out.println(String.format("Unrecognized message type (%s)", messageType.toString()));
                }
            } catch (ParseException e) {
                System.out.println("Error parsing JSON " + json);
            } catch (Exception e) {
                System.out.println("Failed to process packet");
            }
        }
    
    }
    
    private class MyStanzaInterceptor implements StanzaListener {
    	@Override
        public void processPacket(Stanza packet) {
    		System.out.println("Sent: {0}" + packet.toXML());
    	}
    }
    

    /**
     * XMPP Packet Extension for GCM Cloud Connection Server.
     */
    public static final class GcmPacketExtension extends DefaultExtensionElement   {

        private final String json;

        public GcmPacketExtension(String json) {
	    super(GCM_ELEMENT_NAME, GCM_NAMESPACE);
            this.json = json;
        }

        public String getJson() {
            return json;
        }

        @Override
        public String toXML() {
            return String.format("<%s xmlns=\"%s\">%s</%s>",
                    GCM_ELEMENT_NAME, GCM_NAMESPACE,
                    StringUtils.escapeForXML(json), GCM_ELEMENT_NAME);
        }

        public Stanza toPacket() {
            Message message = new Message();
            message.addExtension(this);
            return message;
        }
    }

	public void addStanzaCallback(String key, String value, String to, GcmStanzaCallback callback, long timeoutMsec) {
        connection.addAsyncStanzaListener(new GcmStanzaListener(key, value, callback, timeoutMsec), new GcmStanzaFilter(to));
	}

    private static class GcmStanzaFilter implements StanzaFilter {
		private String to;

		public GcmStanzaFilter(String to) {
			this.to = to;
		}

        @Override
        public boolean accept(Stanza arg0) {
			System.out.println("GcmStanzaFilter called");
            if (arg0.getClass() == Stanza.class) {
                return true;
            } else {
				return (arg0.getTo()!= null) && arg0.getTo().startsWith(to);
            }
        }
    }

	// interface to callbacks for stanzas which match a specified key-value pair.
	public interface GcmStanzaCallback {
		public void run(Map<String, Object> jsonObject);
		public void expired();
	}

	/**
	 * Stanza listener which calls a user-supplied callback when a packet is received with a specified key-value pair
	 */
    private static class GcmStanzaListener implements StanzaListener {
		private static String key;
		private static String value;
		private GcmStanzaCallback callback;
		private long timeoutMsec;

		/**
		 * Constructor: Set up a stanza listener which calls callback.run() if a packet matches
		 * the specified key/value pair, and callback.expired() if timeoutMsec has elapsed 
		 * before the key/value pair was received.
		 * @param key JSON tag to search for
		 * @param value JSON value to match (not matched if null)
		 * @param callback run() is called on match, expired() called if timeoutMsec has elapsed.
		 * @param timeoutMsec elapsed time to wait for a match.
		 */
		public GcmStanzaListener(String key, String value, GcmStanzaCallback callback, long timeoutMsec) {
			this.key = key;
			this.value = value;
			this.callback = callback;
			this.timeoutMsec = timeoutMsec;
		}

        @Override
        public void processPacket(Stanza packet) {
            System.out.println("GcmStanzaListener Received: " + packet.toXML());
            Message incomingMessage = (Message) packet;
            SmackCcsClient.GcmPacketExtension gcmPacket = (SmackCcsClient.GcmPacketExtension) incomingMessage.getExtension(GCM_NAMESPACE);
            String json = gcmPacket.getJson();
            try {
                @SuppressWarnings("unchecked")
                Map<String, Object> jsonObject = (Map<String, Object>) JSONValue.parseWithException(json);

                // present for "ack"/"nack", null otherwise
                Object messageType = jsonObject.get("message_type");

                if (messageType == null) {
                    // Normal upstream data message
                    if (isMatchedUpstreamMessage(jsonObject)) {
						callback.run(jsonObject);
					}
				}
			} catch (ParseException e) {
                System.out.println("Error parsing JSON " + json);
            } catch (Exception e) {
                System.out.println("Failed to process packet");
            }
		}

    	protected boolean isMatchedUpstreamMessage(Map<String, Object> jsonObject) throws InterruptedException {
        	// PackageName of the application that sent this message.
        	System.out.println("upstream message");
        	for (String key : jsonObject.keySet()) {
            	System.out.println("received key = " + key + " value = " + jsonObject.get(key).toString());
        	}
			return jsonObject.containsKey(key) && ((value == null) || value.equals(jsonObject.get(key).toString()));
    	}
	}

	/**
	 * XMPPRunnable so we can receive upstream as well as downstream messages.
	 */

	public static class XMPPRunnable implements Runnable {
		private SmackCcsClient  mCcsClient;
		private boolean terminated = false;

		/**
		 * Create the Smack CCS client, then connect to GCM cloud messaging services with our sender ID and apiKey
     	 * @param senderId Your GCM project number
      	 * @param apiKey API Key of your project
	 	 * @param gcmServer Google Cloud Messaging Server
	 	 * @param gcmPort Google Cloud Messaging TCP port
		 */
		public XMPPRunnable(String senderId, String apiKey, String gcmServer, int gcmPort) throws XMPPException, IOException, SmackException, InterruptedException {
			mCcsClient = new SmackCcsClient();
			mCcsClient.connect(senderId, apiKey, gcmServer, gcmPort);
		}

		public void terminate() {
			terminated = true;
		}

		public SmackCcsClient getCcsClient() {
			return mCcsClient;
		}

		public void run() {
			while (!terminated) {
				try {
					Thread.sleep(10);
				} catch (InterruptedException iex) {
					break;
				}
			}
		}
    }
			

	/**
	 * listener to log connection state changes.
	 */
    private static final class LoggingConnectionListener implements ConnectionListener {

        @Override
        public void connected(XMPPConnection xmppConnection) {
            System.out.println("Connected.");
        }
        

        @Override
        public void reconnectionSuccessful() {
            System.out.println("Reconnecting..");
        }

        @Override
        public void reconnectionFailed(Exception e) {
            System.out.println("Reconnection failed.. ");
        }

        @Override
        public void reconnectingIn(int seconds) {
            System.out.println(String.format("Reconnecting in %d secs", seconds));
        }

        @Override
        public void connectionClosedOnError(Exception e) {
            System.out.println("Connection closed on error.");
        }

        @Override
        public void connectionClosed() {
            System.out.println("Connection closed.");
        }

		@Override
		public void authenticated(XMPPConnection arg0, boolean arg1) {
			// TODO Auto-generated method stub
			
		}
    }

	/**
	 * return the XMPPTCP connection so callers can add listeners and such.
	 */
	public XMPPTCPConnection getConnection() {
		return connection;
	}
}
